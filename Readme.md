
# Fully Vectorized Linear Operator Formulation for Inverse Scattering Problems

This repository contains the code and resources for the Master's Thesis:  
**"Fully Vectorized Linear Operator Formulation for Inverse Scattering Problems"**.

## Overview

This project implements a linear algebra-based approach to identifying defects in objects using wave propagation data.  
Measured data from a grid of points (using transducers) is used to construct a system matrix, which is then inverted to directly solve for defects.  
The code is intended as a working reference and a confirmation of the methods described in the thesis. Users interested in further development are encouraged to modularize and improve the implementation.

## Repository Contents

- **Main.jl** and **Modules/**: Core code for calculations and plotting.
- **Msc_Thesis.pdf**: The full thesis, serving as an appendix to the paper.
- **Additional_Figures/**: Supplementary plots not included in the thesis.
- **Documentation_code/**:  
  - `aluminum_plate_defect_Q_working.ipynb`: Jupyter notebook for Salvus simulations (requires a Salvus license; this is an earlier version).
  - `dispersion.ipynb`: Parameters for the `lambwaves` package, used for dispersion curve analysis.
- **Simulated_data/**: Pre-filtered data for running the code. Most data was generated by the notebook above.
- **Plots/**: Visualizations generated after running `Main.jl` (including .gif animations).

## Quick Start

1. **Install Julia**  
    (Version 1.11.5 is recommended if you encounter issues.)
2. **Clone this repository**  
    `git clone ...` (or download as zip)
3. **Open Julia in the project directory**  
    Open a terminal, navigate to the repository, and type `julia`.
4. **Install dependencies**  
    If you encounter version issues, the exact versions used are documented at the bottom.
    ```julia
    import Pkg
    Pkg.add("HDF5")
    Pkg.add("FFTW")
    Pkg.add("Plots")
    Pkg.add("LinearAlgebra")
    Pkg.add("Measures")
    exit()
    ```
5. **Run the main file**  
    From the terminal:  
    `julia Main.jl`  
    (Alternatively, use `Example_Main.jl` for a smaller test run.)

## Method Summary

- Initialize an "object" (creates a folder structure for your data).
- The code expects measurements from several transducers, taken over a grid (using an LDV).
- Processes the "raw data" to calculate impulse response functions (Green’s functions) between all transducers and grid points.
- Constructs and inverts a system matrix (the calibration step).
- For defect evaluation, only the transducers themselves send/receive pulses.
- The measured responses are compared to the calibrated system to identify defects.

**Note:**  
This code was developed for an iterative and experimental workflow. It is not a polished software product, but rather a reference implementation for research purposes.

## Directory Structure

```
.
├── Main.jl                  # Main script
├── Modules/                 # Core code (see below)
│   ├── command_center.jl
│   ├── custom_plotters.jl
│   ├── data_reader.jl
│   ├── greens_block_finder_V2.jl
│   ├── MatrixGenerator.jl
│   └── evaluate_inverted_matrix.jl
├── Simulated_data/          # Example data
├── Plots/                   # Output plots and animations
├── Additional_Figures/      # Supplementary plots
├── Documentation_code/      # Jupyter notebooks
├── data/                    # Created automatically; stores experiment data
└── Msc_Thesis.pdf           # The full thesis
```

### Data Directory (auto-generated)

The following structure is created automatically for each initialized object:
```
data/
└── <object_name>/
     ├── raw_data/                # Raw wave data from each sensor
     ├── Greens_Blocks/           # Calculated Green’s functions
     ├── defect_measurements/     # Defect measurement results
     ├── Inverted_Matrices/       # Inverted system matrices
     ├── results/                 # (Not actively used—plots are saved in Plots/)
     └── object_data.h5           # Metadata (bandpass, data sizes, etc.)
```

All data is saved in the real frequency domain as `Complex{F32}`.

## Key Functions

- `initialize_new_object`: Sets up a new object, folders, and metadata.
- `add_raw_data`: Adds raw wave data for a sensor.
- `calculate_greens_function`: Computes Green’s functions from the raw data.
- `create_full_system_matrix` / `create_single_system_matrix`: Build and invert the system matrix (several versions exist).
- `evaluate_matrix`: Compares the inverted matrix to defect measurements.

## Parameters and Variables

- **XYZ**: 3D coordinates (x, y, z) for each grid point.
- **Sensors**: Array of sensor locations (order matters).
- **data_freq**: Data acquisition frequency.
- **n_t**: Number of time steps per location.
- **max_freq**: Upper frequency for bandpass filter (do not set above `data_freq/2`).
- **min_freq**: Lower frequency for bandpass filter.
- **debug_mode**: Set to `true` for additional output.

## Dependencies

- Julia packages: `HDF5`, `FFTW`, `Plots`, `LinearAlgebra`, `Measures`
- Versions used:  
  - HDF5 v0.17.2  
  - FFTW v1.8.0  
  - Plots v1.40.8  
  - LinearAlgebra v1.11.0  
- Julia version: 1.11.5